# 页面置换算法

* 缺页率
    * $$\text{缺页率} = \dfrac{\text{缺页发生次数}}{\text{请求页面次数}}$$

1. **最佳置换算法(OPT)** :
	> 一个不可能实现的算法 :
    >
	> 淘汰以后永远不会使用或者最长时间不会访问的算法
2. **先进先出置换算法(FIFO)**
    > 先进先出算法选择最早进入内存的页面进行替换
    >
    > 通过队列记录页面进入内存的顺序，队列长度由内存块数量决定。
    >
    > 可能出现贝拉迪异常，即内存块增多时缺页率不降反升
3. **最近最久未使用置换算法(LRU)**
    > 选择最久未使用的页面进行替换
    > 
    > 通过访问字段记录页面被访问的时间，选择时间最长的页面
    >
    > 实现需要硬件支持，开销较大，但性能接近最佳置换算法
4. **时钟置换算法(CLOCK)** 最近未用算法（NRU）
	> 1. 简单 CLOCK 置换算法 : (最近未用置换算法 NRU)
    > 
	>   > 每个页面有一个访问位: 当某个页面被装入或者访问的时候, 访问位设为 $$\displaystyle{1}$$ , 算法将内存中的页面链接成一个循环队列，并有一个替换指针与之相关联, 当要替换页面的时候就会依次寻找, 当遇到 $$\displaystyle{1}$$ 的时候就将其置为 $$\displaystyle{0}$$ , 之后跳到下一位, 如果某个页面访问位为 $$\displaystyle{0}$$ , 那么置换这个页面
	> 
	> 2. 改进型 CLOCK 算法 : 
	> 	> 依次寻找并淘汰以下的页面 :
	> 	> > 1类，4：0，M：0：最近未被访问，且未被修改，是最佳的淘汰页。不修改
	> 	> > 2类：0，M=1：最近未被访问，但己被修改，是次佳的淘汰页。 **这一轮将访问位为 1 的设置为 0**
	> 	> > 3类：1，M=0：最近己被访问，但未被修改，可能再被访问。不修改
	> 	> > 4类：1，M=1：最近己被访问，且己被修改
	> 	> 
	> 	> 主要是通过两个标志位实现, 一个是访问位, 一个是修改位
	> 	> ![Pasted image 20241224142823.png](./img/Pasted%20image%2020241224142823.png)