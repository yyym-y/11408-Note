# 动态分区分配算法

* **首次适应算法(First Fit)**
    * 从低地址部分开始查找，找到第一个能够满足大小的空闲分区
    * 保留了高地址的大空闲分区,有利于大作业的装入,但会让低地址的内存碎片增加
* **最佳适应算法(Best Fit)**
    * 优先使用更小的空闲区间，按容量递增次序排列空闲分区
    * 通常性能会更差,每次分配都会留下越来越多的小的外部碎片,通常比 First Fit 更差
* **最坏适应算法(Worst Fit)**
    * 优先使用最大的连续空闲区，按容量递减次序排列空闲分区
    * 大分区被不断分割，可能导致大进程无连续空闲区可用
* **临近适应算法(Next Fit)(循环首次适应算法)**
    * 解决首次适应算法低地址部分碎片多的问题，从上一次查找结束的位置开始往后查找
    * 空闲分区按地址递增顺序排列，形成循环列表，分配内存时从上次结束位置开始查找
    * 高地址部分的大分区更有可能被用完，导致大进程无连续空闲区可用(通常比 First Fit 性能差)
* **基于索引搜索的分配算法**
    * 关键点在于根据内存分区的大小构建索引, 一个分区大小对应一个链表, 所有等于这个大小的分区都挂在这个链表中, 可以理解为是局部的静态分区分配
    * **快速适应算法**
        * 根据索引表找到第一个大于等于申请大小的起始链表,将第一个分区分配给他
        * 优点:查找效率高,不会产生外部碎片
        * 缺点:要考虑相邻大小合并分区,系统开销大
    * **伙伴系统**
        * 分区的大小都是 $$2^k \quad k\in Z$$ , 当分区大小在 $$2^{k - 1} \le \text{Need} < 2^{k}$$ , 将会分配 $$2^{k - 1}$$ 索引对应的第一个分区, 如果该链表为空,就会分配 $$2^k$$ 链表的分区, 不过一半用于分配, 一般拆分到 $$2^{k - 1}$$ 链表中.
        * 如果下一层链表也为空, 那么会依次向上寻找直到找到满足的条件,,之后一直拆分到 $$2^{k - 1}$$ 的分块
        * 回收的时候要合并相邻块
    * **哈希算法**
        * 使用哈希算法快速定位满足的链表头地址