# 数据寻址


## 知识总览 (寻址方式的统一表示)

为了更灵活地支持多种数据寻址方式，指令结构通常会进行改进。

* **指令结构改进**:
    * **操作码 (OP)**
    * **寻址特征**: 引入一个专门的寻址特征位（例如4位，可表示16种寻址方式），指明如何解释后续的地址码。
    * **形式地址 (A)**: 指令中给出的地址码。

* **关键术语**:
    * **形式地址**: 指令中**直接给出的地址码**。
    * **有效地址 (EA)**: 经过寻址方式计算后得到的**最终真实地址**。

* **多地址指令处理**: 对于包含多个操作数的指令，**每个地址码通常可以单独配置其寻址特征位**，从而允许不同的操作数采用不同的寻址方式。

---

## 直接寻址

* **定义**: **形式地址 `A` 即为操作数的有效地址 `EA`**。表达式为 **`EA = A`**。
* **访存过程**:
    1.  **取指令**: 1次访存。
    2.  **根据 `A` 访问操作数**: 1次访存。
    * **总计**: **2次访存**。
* **优点**:
    * 执行过程简单，无需复杂的地址转换。
    * 在执行阶段只需1次访存即可获取操作数。
* **缺点**:
    * **寻址范围受限**: 寻址范围直接由地址码的位数决定。
    * **地址修改困难**: 如果操作数的内存地址发生变化，需要修改指令本身，这在程序运行时很不灵活。
* **适用场景**: 操作数地址固定不变的简单程序或数据访问。

---

## 间接寻址

### 1) 间接寻址的定义与过程

* **定义**: 指令的地址字段给出的形式地址 `A` **不是操作数的真正地址**，而是**操作数有效地址所在的存储单元的地址**，即“操作数地址的地址”。表达式为 **`EA = (A)`**。
* **访存过程**:
    1.  **第一次访存**: 取出指令本身。
    2.  **第二次访存**: 根据形式地址 `A` 读取主存单元，获取其中存储的**操作数真实地址**。
    3.  **第三次访存**: 根据获取到的真实地址，最终读取**操作数**。
* **表示方法**: `(A)` 表示地址 `A` 处存储的**内容**。

### 2) 两次间接寻址

* **多级寻址机制**: 间接寻址可以有多级。例如，如果第一次读取的存储单元的**首位为1**（作为标志位），则表示还需要继续寻址；如果**首位为0**，则表示当前读取的数据就是最终的有效地址。
* **典型应用**: 适用于多层函数调用场景，例如函数A调用函数B，函数B又调用函数C。在函数返回时，可以通过多级间接寻址来找到正确的返回地址。

> 间接寻址的优点

* **扩大寻址范围**: 有效地址的位数可以**大于形式地址的位数**。例如，指令中形式地址只有16位，但通过间接寻址，可以获取到一个32位的有效地址，从而访问更大的内存空间。
* **编程便利性**: 特别适合实现**子程序返回**、**多级跳转**以及**数据结构中的指针**等场景。

> 间接寻址的缺点

* **执行效率低**: **每增加一级间接寻址就需要增加一次访存操作**。
* **时间开销大**: 相比直接寻址，间接寻址需要更多的访存周期。一次间接寻址需要3次访存（取指令+取地址+取操作数），两次间接寻址则需要4次访存。

---

## 寄存器寻址

* **定义**: 指令字中直接给出操作数所在的**寄存器编号 `Ri`**，操作数直接在所指的寄存器内。表达式为 **`EA = Ri`**。
* **执行特点**:
    1.  **取指令**: 1次访存。
    2.  **执行指令**: **0次访存**（因为操作数直接在CPU内部的寄存器中，无需访问主存）。
* **优势**:
    * **执行速度快**: 寄存器访问速度远快于主存。
    * **指令字长短**: 寄存器编号所需的位数通常很少。
    * 支持**向量/矩阵运算**等需要频繁访问数据的场景。
* **局限**:
    * 寄存器成本高，导致数量有限。
    * 寻址能力受限于寄存器的数量。

---

## 寄存器间接寻址

* **定义**: **寄存器中存储的是操作数的主存地址**。表达式为 **`EA = (Ri)`**。
* **访存过程**:
    1.  **取指令**: 1次访存。
    2.  **执行指令**: 1次访存（CPU根据寄存器 `Ri` 中存储的地址，访问主存单元获取操作数）。
* **比较优势**: 比主存间接寻址**更快**，因为它减少了第一次从主存中获取操作数地址的访存（直接从寄存器获取）。总计2次访存。
* **典型应用**: 适用于需要间接寻址但又追求较高执行效率的场景，例如数组遍历、数据结构中链表的操作等。

---

## 隐含寻址

* **定义**: **操作数地址不显式给出**，而是**隐含在指令设计中**，例如默认使用累加器（ACC）寄存器作为其中一个操作数或结果的存放地。
* **实现特点**:
    * 需要**专用硬件**支持隐含的存储位置。
    * 可以使**指令字长更短**，因为无需显式指明所有操作数地址。
* **典型示例**: 单地址指令中，另一个操作数默认来自累加器。例如 `ADD A` 指令，隐含了 `(ACC) + (A) -> (ACC)`。

---

## 立即寻址

* **定义**: **形式地址字段直接存储操作数值本身**（被称为**立即数**）。即形式地址 `A` 就是操作数 `operand`。
* **标识方法**: 在汇编语言中，通常用 **#符号** 标识立即数，例如 `ADD #5`。
* **执行特点**:
    1.  **取指令**: 1次访存（指令本身就包含了操作数）。
    2.  **执行指令**: **0次访存**（操作数在指令内部，无需额外访问主存）。
* **优势**:
    * **执行速度最快**，因为它不需要额外的访存来获取操作数。
* **局限**:
    * 操作数的表示范围受限于地址字段的位数。例如，如果地址字段只有 `n` 位，那么只能表示范围为 $$-2^{n-1}$$ 到 $$2^{n-1}-1$$ 的补码数。

---

## 偏移寻址

---


### 基址寻址

#### 1) 基址寻址原理

* **计算公式**：**`EA = (BR) + A`**，其中 `BR` 是**基址寄存器**的内容，`A` 是指令中的**形式地址**。
* **硬件实现**：
    * CPU 中可以设置**专用的基址寄存器**。
    * 也可以通过指令**指定某个通用寄存器作为基址寄存器**。
    * **寄存器位数**：寄存器编号的位数取决于通用寄存器的数量，例如 8 个通用寄存器需要 3 位编码（$$2^3=8$$）。
* **操作系统关联**：基址寻址与操作系统中的“**重定位寄存器**”概念相同，主要用于**程序的装入和管理**。

#### 2) 基址寻址的作用

* **程序浮动**：它允许程序在内存中**从任意地址开始存放**，而无需修改程序内部的地址码。只需修改基址寄存器 `BR` 的值即可。
    * **示例**：如果程序起始地址从 0 变为 100，形式地址 5 对应的实际地址将是 105（100 + 5）。
* **支持多道程序**：在多道程序并发运行时，操作系统可以通过修改基址寄存器 `BR`，让不同的程序指向各自在内存中的起始地址。
* **权限管理**：基址寄存器的内容通常由**操作系统管理**，**用户程序无法修改**。即使通用寄存器被指定为基址寄存器，在作为基址使用时也会变为只读。
* **地址扩展**：通过基址寄存器，可以有效扩展指令的寻址范围。

**关键点**：
* 基址寄存器的内容由**操作系统**确定，并在程序执行期间通常保持不变。
* **有效地址**由**基地址（固定）+ 形式地址（相对基地址的偏移量，可变）**构成。
* **限制**：普通程序员不能直接修改基地址，内存分配由操作系统统一管理。

---

### 变址寻址

#### 1) 变址寻址原理

* **定义**：**有效地址 `EA` 等于指令字中的形式地址 `A` 与变址寄存器 `IX` 的内容相加之和**，即 **`EA = A + (IX)`**。
* **寄存器类型**：`IX` 可以是专用的变址寄存器，也可以是指定的通用寄存器。
* **面向用户特性**：**变址寄存器是面向用户的**，其内容在程序执行过程中**可由用户程序改变**（作为偏移量）。而指令中的**形式地址 `A` 保持不变**（作为基地址）。
* **与基址寻址的区别**：
    * **寄存器权限**：变址寄存器内容可由程序员修改，而基址寄存器内容通常由操作系统管理。
    * **角色分配**：在变址寻址中，`IX` 被视为**偏移量**，形式地址 `A` 被视为**基地址**。这与基址寻址中 `BR` 作为基地址、`A` 作为偏移量的情况**恰好相反**。

#### 2) 变址寻址的作用

* **循环程序实现**：通过改变变址寄存器 `IX` 的值，可以实现对**数组元素的连续访问**，极大地简化了循环程序的编写。
* **编程优势**：
    * 形式地址 `A` 固定为数组的首地址（作为基地址）。
    * `IX` 作为可编程的**偏移量**，程序员通过修改其值实现数组的遍历。
    * 程序长度不随数据量增加而线性增长，大大提高了代码的简洁性和效率。
* **典型应用**：特别适合处理**数组操作和编制循环程序**。

---

### 基址和变址复合寻址

#### 1) 基址和变址复合寻址原理

* **复合原理**：将基址寻址和变址寻址两种寻址规则结合使用，类似于数学中的复合函数概念。通常是**先进行基址寻址计算，再进行变址寻址计算**。
* **地址计算**：**`EA = (BR) + A + (IX)`**，其中 `BR` 是基址寄存器的内容，`A` 是指令中的形式地址，`IX` 是变址寄存器的内容。
* **实际应用**：当程序在内存中的存放位置改变时（例如从地址 0 变为地址 100），通过基址寄存器 `BR` 记录程序的起始地址（100），配合变址寄存器 `IX` 来实现数组元素的正确访问。
* **示例说明**：若程序起始地址为 100，数组 `a[2]` 存放在相对于程序起始地址偏移量为 7 的位置（即 `100+7=107` 是 `a[0]` 的地址），那么 `a[2]` 的实际地址是 `109`。计算过程为：先通过基址寻址计算出数组的基地址 `100 + 7 = 107`（这是 `a[0]` 的地址），再通过变址寻址加上偏移量 `2`（索引值），得到 `107 + 2 = 109`，指向 `a[2]`。

---

### 相对寻址

#### 1) 相对寻址原理

* **核心公式**：**`EA = (PC) + A`**，其中 `A` 是用**补码表示的偏移量**（可正可负）。
* **PC 特性**：**取指令后 PC 会自动增加**，增加量取决于当前指令的长度（例如 2 字节指令加 2，4 字节指令加 4 等）。
* **关键区别**：**偏移量 `A` 是相对于** PC 指向的**下一条指令地址的位移量**。
    * （**注意**：有些教材可能误描述为“相对于当前指令地址”，但更准确的理解是相对于**取指后 PC 的值**，即下一条指令的地址）。
* **表示方法**：偏移量 `A` 采用**补码表示**，允许实现**正向和反向跳转**。

#### 2) 相对寻址的作用

* **程序浮动**：使**代码段在程序内部移动时**无需修改跳转指令的地址参数，只需保持相对偏移量不变。
    * **实现原理**：跳转指令采用相对寻址后，无论该代码段整体移动到内存何处，`PC + A` 总能计算出正确的目标地址。
* **与基址寻址的区别**：**基址寻址解决的是整个程序在内存中的浮动问题**（程序的绝对地址位置），而**相对寻址解决的是代码段在程序内部的浮动问题**（指令之间的相对位置）。
* **典型应用**：特别适合用于**转移指令**（如循环跳转、条件分支），保证即使循环体的位置发生变化，仍能正确跳转。
* **配合分段**：结合数据分段机制，可使数据访问地址保持相对固定，进一步简化地址管理。

---

### 回顾

* **偏移寻址分类**：**相对寻址、基址寻址和变址寻址**都归为偏移寻址。它们的共同特点是基于一个基地址加上偏移量来计算有效地址。
* **相对寻址特点**：
    * 主要用于**转移指令**。
    * 有效地址计算：`EA = (PC) + A`。
    * **特别注意**：PC 在取指令后会指向**下一条指令**的起始地址，因此偏移量 `A` 是相对于**下一条指令**的地址而言。
* **基址寻址应用**：主要用于**多道程序并发运行**时的内存管理，由**操作系统**管理基址寄存器 (`BR`) 的值。
* **变址寻址优势**：便于实现**循环程序或数组访问**。有效地址计算：`EA = A + (IX)`。
* **访存次数**：这三种偏移寻址方式在指令执行阶段都**只需访存 1 次**（不算取指令本身）。

---

### 堆栈寻址

---

**堆栈寻址**是一种特殊的寻址方式，其核心在于操作数被存放在一个被称为**堆栈（Stack）**的特殊数据结构中。这种寻址方式**隐含地使用堆栈指针 (SP)** 作为操作数的地址，因此指令中无需显式地给出操作数的存放地址。

* **核心特征**：堆栈严格遵循“**后进先出 (LIFO)**”的原则来管理存储区。**SP 寄存器始终指向栈顶元素**，即下一个将被操作（读取或写入）的元素。
* **实现方式**：堆栈可以通过两种方式实现：**专用寄存器组**（称为**硬堆栈**）或**主存中的特定区域**（称为**软堆栈**）。

---


## 2. 硬堆栈和软堆栈

堆栈的实现方式分为硬件和软件两种，各有优劣：

### 硬堆栈 (Hardware Stack)

* **实现**：由 CPU 内部的**专用寄存器组**（例如 R0-R3）构成。
* **特点**：
    * 执行期间**无需访问内存**，直接在寄存器中操作。
    * 访问速度**极快**，但**成本较高**。
    * SP 只需少量比特位来寻址这些寄存器（例如，4 个寄存器只需 2 比特）。
* **访存差异**：指令执行期间**0 次访存**（不包括取指令本身）。

### 软堆栈 (Software Stack)

* **实现**：在**主存中划定一个特定的区域**作为堆栈。
* **特点**：
    * 每次 POP/PUSH 操作都需要**进行内存访问**。
    * **成本较低**，但访问速度**较慢**。
    * 实际的计算机系统**主要采用软堆栈**，尤其是在支持函数调用、传递参数和保存返回地址等场景中。
* **访存差异**：每次栈操作（POP/PUSH）需要**1 次访存**（不包括取指令本身）。

### 应用场景对比

* **硬堆栈**：适合对性能要求极高的计算场景，例如某些高性能控制器或专用处理器。
* **软堆栈**：广泛用于程序运行时，管理**函数调用、局部变量、参数传递**以及**返回地址**等信息。
