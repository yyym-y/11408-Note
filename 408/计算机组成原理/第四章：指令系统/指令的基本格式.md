# 指令系统


### 指令组成

一条机器指令通常由两部分组成：

* **操作码（Opcode）**: 指明了指令要执行的**操作类型**。例如，`000100` 可能代表乘法运算。
* **地址码（Operand Address）**: 指明了操作数所在**内存地址**。例如，`0000000110` 可能指向变量 `b` 的存储单元。

### 指令执行的微观过程

一条指令的执行通常分为三个主要阶段：

#### 取指阶段

* **PC自动+1**: **程序计数器（PC）**自动增加，指向下一条待执行指令的地址。例如，如果当前 `(PC)=1`，则 `(MAR)=1`（**内存地址寄存器**）。
* **内存读取指令到IR**: 根据 `MAR` 中的地址，从内存中读取指令内容，并将其存入**指令寄存器（IR）**。例如，`(MDR)=0001000000000110` 会被传输到 `(IR)`。

#### 分析阶段

* **操作码送CU解码**: `IR` 中的操作码部分（`OP(IR)`）被送往**控制单元（CU）**进行解码，以识别指令类型。例如，`000100` 被识别为乘法。
* **地址码送MAR取操作数**: `IR` 中的地址码部分（`Ad(IR)`）被送往 `MAR`，准备从内存中获取操作数。例如，如果地址码是 `6`，则 `MAR=6`。

#### 执行阶段

* **取操作数到MQ**: 根据 `MAR` 中的地址，从内存中读取操作数到**乘商寄存器（MQ）**。例如，`(MDR)=3` 被传输到 `(MQ)`。
* **ALU执行运算**: **算术逻辑单元（ALU）**执行指令指定的运算。例如，`(MQ)` 中的 `3` 乘以 **通用寄存器X** 中的 `2`，结果 `6` 存入 `(ACC)`。

---


我们将从以下几个维度对指令进行分类和分析：

* **地址码数目**: 指令中包含的地址码数量。
* **指令长度**: 一条指令所占用的二进制位数。
* **操作码长度**: 指令中操作码部分所占用的二进制位数。
* **操作类型**: 指令执行的具体功能类别。

---

## 3. 指令的定义

### 基本概念

* **最小功能单位**: **指令**是计算机执行操作的**基本命令**，也是计算机能够理解和执行的最小功能单位。
* **指令系统**: **指令系统（Instruction Set Architecture, ISA）**是**一台计算机所有指令的集合**。例如，x86和ARM是两种常见的指令系统架构。

### 关键特性

* **架构依赖性**: 计算机**只能执行自身指令系统的指令**。这意味着为一种架构设计的软件不能直接在另一种架构上运行。
* **软硬件接口**: 指令系统是**软件控制硬件的接口**。软件通过发送指令来指挥硬件执行特定的操作。例如，Intel芯片执行x86指令。

---


一条指令通常由**操作码（OP）**和**地址码（A）**两部分组成，是机器语言中具有特定含义的二进制代码。

### 功能划分

* **操作码**: 指明指令要“**做什么**”，例如加、减、乘、除等运算。
* **地址码**: 指明“**对谁操作**”，即操作对象（数据或指令）的**位置**。

## 按地址码数目分类

### 1) 零地址指令

#### 适用场景

* **无操作数指令**: 某些指令不需要操作数，例如**停机、关中断、空操作**等。
* **堆栈计算机**: 在**堆栈型计算机**中，操作数隐含在**栈顶（TOS）**和**次栈顶（NOS）**。例如，后缀表达式的运算就常使用堆栈来实现。如： 表达式 `(A * B) + (C * D)` 的后缀表达式为 `A B * C D * +`

#### 运算原理

操作数通过**栈结构**隐含存储。运算结果通常会**压回栈顶**。



### 2) 一地址指令

#### 单操作数情况

* **操作类型**: 适用于只需要一个操作数的运算，如**加1、减1、取反、求补**等。
* **执行过程**: 例如，指令 `INC A1`（对A1单元内容加1）。这需要 **3次访存**：
    1.  **取指**: 从内存中取出 `INC A1` 指令。
    2.  **读A1**: 读取地址 `A1` 处的操作数。
    3.  **写A1**: 将运算结果写回地址 `A1` 处。

#### 隐含操作数情况

* **典型结构**: 许多一地址指令会**隐含使用累加器（ACC）**作为其中一个操作数或结果存放地。例如，`ADD A1` 实际上是 `(ACC) + (A1) -> (ACC)`。
* **访存次数**: 此时，只需要 **2次访存**：
    1.  **取指**: 取出 `ADD A1` 指令。
    2.  **读A1**: 读取地址 `A1` 处的操作数。
* **符号说明**:
    * `A` 表示主存地址。
    * `(A)` 表示该地址 `A` 存储的**内容**。

### 3) 二、三地址指令

#### 二地址指令

* **格式**: `OP A1, A2`。表示 `(A1) OP (A2) -> (A1)`。
* **访存次数**: 通常需要 **4次访存**：
    1.  **取指**: 取出指令。
    2.  **读A1**: 读取地址 `A1` 处的操作数。
    3.  **读A2**: 读取地址 `A2` 处的操作数。
    4.  **写A1**: 将结果写回地址 `A1` 处（覆盖原有内容）。

#### 三地址指令

* **格式**: `OP A1, A2, A3`。表示 `(A1) OP (A2) -> (A3)`。
* **访存次数**: 通常需要 **4次访存**：
    1.  **取指**: 取出指令。
    2.  **读A1**: 读取地址 `A1` 处的操作数。
    3.  **读A2**: 读取地址 `A2` 处的操作数。
    4.  **写A3**: 将结果写回地址 `A3` 处。
* **区别**: 三地址指令**显式指定结果的存储位置**（`A3`），因此**不会覆盖源操作数**（`A1`）。而二地址指令则将结果存回 `A1`，覆盖了 `A1` 的原始内容。

### 4) 四地址指令

* **特殊字段**: 四地址指令除了 `OP`、`A1`、`A2`、`A3` 外，还包含一个**`A4` 字段**，该字段指明了**下一条指令的地址**。
* **执行特点**: 指令执行完毕后，程序计数器 `PC` 的值会被修改为 `A4` 指定的地址，从而实现**非顺序执行**（例如跳转）。
* **访存次数**: 通常需要 **4次访存**：
    1.  **取指**: 取出指令。
    2.  **读A1**: 读取地址 `A1` 处的操作数。
    3.  **读A2**: 读取地址 `A2` 处的操作数。
    4.  **写A3**: 将结果写回地址 `A3` 处。


> 地址码位数影响

> * **`n` 位地址码**: 可以寻址 $$2^n$$ 个存储单元。
> 
>* **地址码数量增加**: 当指令字长固定时，如果地址码数量增加（例如从一地址到二地址），则每个地址码的位数就会减少，从而**降低了寻址能力**（能寻址的内存范围变小）。

#### 分类总结表

| 地址码数目 | 格式        | 描述                                                               | 访存次数（典型） | 适用场景           |
| :--------- | :---------- | :----------------------------------------------------------------- | :--------------- | :----------------- |
| 0地址      | `OP`        | 无操作数或操作数隐含在栈中                                         | 1（取指）        | 停机，堆栈计算机   |
| 1地址      | `OP A1`     | `(ACC) OP (A1) -> (ACC)` 或 `OP (A1) -> (A1)`                    | 2-3              | 单操作数运算       |
| 2地址      | `OP A1, A2` | `(A1) OP (A2) -> (A1)`                                             | 4                | 算术运算           |
| 3地址      | `OP A1, A2, A3` | `(A1) OP (A2) -> (A3)`                                             | 4                | 显式结果存储运算   |
| 4地址      | `OP A1, A2, A3, A4` | `(A1) OP (A2) -> (A3)`，下条指令地址为 `A4`                          | 4                | 程序跳转与控制     |


## 指令按指令长度分类

#### 关键概念

* **指令字长**: 一条**指令的总长度**，即该指令所占用的二进制位数。指令字长可以是**可变**的。
* **机器字长**: **CPU一次整数运算能够处理的位数**。这是CPU的固有属性，通常是**固定**的（例如32位或64位）。
* **存储字长**: **一个存储单元能够存储的代码位数**。这也是内存的固有属性，通常是**固定**的。

#### 分类标准

* **定长指令字结构**: 所有指令的长度都**相同**。
* **变长指令字结构**: 不同指令的长度可以**不同**。

#### 性能影响

指令字长直接影响**取指时间**。例如，如果指令字长为32位，而存储字长为16位，那么取一条指令就需要**2次访存**。

## 指令按操作码长度分类

#### 定长操作码

* **特点**: 所有指令的操作码长度都**相同**。
* **优势**: 控制器译码电路设计相对**简单**。
* **限制**: 如果操作码有 `n` 位，则最多只能支持 $2^n$ 条指令。

#### 可变长操作码

* **特点**: 不同指令的操作码长度可以**不同**。
* **优势**: 指令设计**灵活性高**，可以编码更多指令，或为常用指令分配更短的操作码。
* **缺点**: 控制器设计和译码过程相对**复杂**。

## 指令按操作类型分类

根据指令执行的功能，可以将指令分为以下几类：

#### 数据传送类

* **功能**: 实现**CPU与主存之间的数据交换**。
* **示例**:
    * **LOAD**: 将数据从**主存加载到寄存器**。
    * **STORE**: 将数据从**寄存器存储到主存**。

#### 运算类

* **算术运算**: 执行基本的数学运算，如**加、减、乘、除**。
* **逻辑运算**: 执行逻辑操作，如**与（AND）、或（OR）、非（NOT）、异或（XOR）**。
* **移位运算**: 对二进制数进行移位操作，包括**算术移位、逻辑移位、循环移位**。

#### 程序控制类

* **功能**: **改变程序的执行流**，不再按照顺序执行。
* **实现**: 通过**修改程序计数器（PC）的值**来实现。
* **示例**:
    * **跳转（JUMP）**: 无条件跳转到指定地址。
    * **分支（BRANCH）**: 根据条件判断是否跳转。
    * **函数调用/返回（CALL/RETURN）**: 用于子程序的调用和返回。
    * **中断（INTERRUPT）**: 响应外部或内部事件，暂停当前程序执行，转而执行中断服务程序。

#### 输入输出类

* **功能**: 实现**CPU与I/O设备之间的数据交换**。
* **特点**: 通常涉及对**I/O端口**的操作。

---

#

## 二、知识小结

| 知识点             | 核心内容                                                                                                 | 考试重点/易混淆点                                                                 | 难度系数 |
| :----------------- | :------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------- | :------- |
| **指令系统基本概念** | 指令是计算机执行操作的最小功能单位，由操作码和地址码组成；指令集是计算机所有指令的集合             | 指令集与体系结构的关系（如x86与ARM架构差异）                                      | ⭐⭐      |
| **指令格式分类（按地址码数目）** | 零地址（停机指令/堆栈运算）、一地址（单操作数或隐含ACC）、二地址（算术运算）、三地址（显式结果存储）、四地址（跳转指令） | 不同地址指令的访存次数差异（零地址1次取指，一地址2-3次，二/三/四地址4次）           | ⭐⭐⭐     |
| **指令字长与结构** | 指令字长决定取指时间；分为定长（如半/单/双字长）和变长指令字结构                                         | 机器字长、存储字长与指令字长的区别                                                | ⭐⭐      |
| **操作码设计类型** | 定长操作码（译码简单，灵活性低） vs 可变长操作码（译码复杂，灵活性高）                                   | 操作码位数与指令数量关系（n位→$2^n$条指令）                                       | ⭐⭐⭐     |
| **操作类型分类** | 数据传送（主存-CPU）、运算类（算术/逻辑/移位）、程序控制（跳转/调用）、输入输出（CPU-IO设备）         | 转移类指令的本质（修改PC值改变执行流）                                            | ⭐⭐      |
| **扩展操作码指令格式** | 定长指令字结构下可变操作码位数的设计方法（下节重点）                                                     | 灵活性与硬件复杂度的权衡                                                        | ⭐⭐⭐⭐   |
| **堆栈型计算机原理** | 通过后缀表达式和零地址指令实现运算（操作数隐含在栈顶）                                                   | 中缀表达式转后缀的方法                                                            | ⭐⭐⭐     |
| **指令执行与访存关系** | 不同地址指令的访存次数对比（如二地址需4次，三地址需4次含结果写回）                                       | 地址码位数与寻址能力的关系（n位→$2^n$寻址范围）                                   | ⭐⭐⭐     |