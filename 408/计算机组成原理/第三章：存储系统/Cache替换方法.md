# 一、Cache 替换算法

## 2. 替换算法解决的问题

替换算法是解决“Cache 满时淘汰哪一块”问题的关键。但并非所有 Cache 映射方式都需要复杂的替换算法。

* **应用场景：**
    * **全相联映射：** 由于主存的任何块都可以被映射到 Cache 的**任意一个块**中，当 Cache 满时，系统需要在所有 Cache 块中选择一个进行替换。因此，全相联映射**需要替换算法**。
    * **直接映射：** 主存中的每一个块只能映射到 Cache 中的**唯一固定位置**。因此，当该固定位置已被占据时，新调入的块会直接**覆盖**掉旧的块。直接映射**无需替换算法选择**，而是采用“覆盖式”替换。
    * **组相联映射：** 主存中的块可以映射到 Cache 中**某一特定组内的任意一个块**。当一个组满时，系统只需要在该组内部选择一个块进行替换。因此，组相联映射**需要替换算法**，但选择范围仅限于组内。

* **关键结论：**
    * 只有**全相联映射**和**组相联映射**需要复杂的替换算法来决定淘汰哪个块。
    * **直接映射**由于其固定的映射规则，不存在选择问题，而是直接进行“覆盖式”替换。

---

## 3. 本节总览

本节将详细介绍四种主要的 Cache 替换算法：

* **随机算法（RAND）：** Random Replacement
* **先进先出（FIFO）：** First-In, First-Out
* **近期最少使用（LRU）：** Least Recently Used
* **最近不经常使用（LFU）：** Least Frequently Used

---

## 4. 随机算法


**算法规则：** 当 Cache 满时，随机选择 Cache 中的一个块进行替换，不考虑任何历史信息或局部性原理。

**特点：**
* **实现简单：** 硬件实现非常容易，只需要一个随机数发生器。
* **性能不稳定：** 由于完全随机，不考虑程序的局部性原理，可能将即将再次访问的热点数据替换出去，也可能保留很久不用的数据。因此，命中率通常较低且波动大。

---

## 5. 先进先出算法

### 5.1 例题：Cache 替换过程

**算法规则：** 替换 Cache 中最先被调入（即在 Cache 中停留时间最长）的块。

**实现方式：** 可以通过为每个 Cache 块设置一个时间戳或使用一个循环队列/指针来实现。当 Cache 满时，替换指针指向的块，然后指针移向下一个块，形成一个循环。例如，按行号轮转替换（0 → 1 → 2 → 3 → 0...）。


**缺点：**
* **可能淘汰高频访问块：** FIFO 算法只考虑进入 Cache 的时间，而不考虑块被访问的频率。一个被频繁访问的块（例如，一个核心的函数代码或全局变量），如果它是最早进入 Cache 的，也可能被淘汰。这会降低命中率。
* **未能有效利用局部性原理：** 它没有利用时间局部性（频繁访问的应保留）和空间局部性（相邻的可能很快访问）。
* **实际运行效果不理想：** 容易出现上述的**“抖动现象”**，即一个块刚被换出，很快又因为再次访问而被换入，导致 Cache 效率低下。

---

## 6. 近期最少使用算法

### 6.1 基本概念

**核心思想：** LRU 算法基于**时间局部性原理**，认为在最近一段时间内没有被访问的块，在未来一段时间内被访问的可能性也较低。因此，它替换的是在 Cache 中停留时间最长且**最久未被访问**的块。

**实现方式：**
* 为每个 Cache 块设置一个**计数器**（或时间戳），记录该块自上次被访问以来已经过去了多久。
* **计数器规则：**
    * **未命中且有空闲行：** 将新调入的块装入空闲行，其计数器置为 0。Cache 中所有非空闲行的计数器**加 1**。
    * **命中时：** 命中行的计数器**清零**。**所有比命中行原计数器小的计数器加 1**，比它大的计数器保持不变（这样可以准确反映其他块相对于命中块的“老旧”程度）。
* **替换时：** 选择计数器值**最大**的那个块进行替换。

**硬件实现优势：**
* 如果 Cache 共有 $$N$$ 个块（行），则每个计数器只需要 $$log_2 N$$ 比特来表示。例如，对于 4 个 Cache 块，每个计数器只需要 2 比特（可表示 0-3）。这在硬件上相对容易实现。


**硬件模拟（计数器变化详解）：**
LRU 的计数器逻辑通常不是简单的 +1。更精确的硬件实现是：
* **新调入：** 调入到空闲行 $$i$$，$$\text{counter}[i] = 0$$. 所有其他在 Cache 中的块 $$j$$，如果 $$\text{counter}[j]$$ 尚未达到最大值，则 $$\text{counter}[j] = \text{counter}[j] + 1$$.
    > 新加入的行计数器为0, 其余不空闲的块 +1
* **命中：** 命中行 $$i$$，$$\text{counter}[i] = 0$$. 所有其他在 Cache 中的块 $$j$$，如果 $$\text{counter}[j] < \text{原} \_ \text{counter}[i]$$，则 $$\text{counter}[j] = \text{counter}[j] + 1$$. 所有 $$\text{counter}[j] > \text{原} \_ \text{counter}[i]$$ 的块不变。
    > 命中的行计数器清零, 同时比他小的计数器全部加一
* **替换：** 选择 $$\text{counter}$$ 值最大的块进行替换。
    > 新装入的行置为0, 其他计数器加一

**算法特性：**
* **符合时间局部性原理：** 倾向于保留近期经常使用的块，因此实际命中率通常较高。
* **可能发生抖动现象：** 如果程序循环访问的块数量超过 Cache 的容量，LRU 仍会发生抖动，导致频繁的换入换出。例如，一个 4 块的 Cache，如果程序循环访问 {A, B, C, D, E}，LRU 每次都会淘汰一个刚被使用的块。
* **易错点：**
    * 命中时，只有命中行的计数器清零。**比命中行原计数器小的计数器加 1**，比它大的不变。这样才能准确体现“最久未用”的相对关系。
    * 替换时，只需要比较计数器**相对大小**，找出最大的即可，不必关注具体数值。

---

## 7. 最不经常使用算法

**核心思想：** LFU 算法认为在 Cache 中被访问次数最少的块，在未来被访问的可能性也较低。因此，它替换的是 Cache 中**访问次数最少**的块。

**实现方式：**
* 为每个 Cache 块设置一个**计数器**，记录该块被访问的**总次数**。
* **计数器规则：**
    * 新调入块时，计数器通常置为 0。
    * 每次命中访问时，对应块的计数器**加 1**。
* **替换策略：** 当 Cache 满且需要替换时，选择计数器值**最小**的那个块进行淘汰。
    * **当多个块计数器相同时：**
        * **按 Cache 行号递增顺序优先淘汰：** 例如，如果行 0 和行 2 的计数器都最小且相同，优先淘汰行 0。
        * **按先进先出 (FIFO) 规则淘汰：**                                           |

**算法缺陷：**
* **不遵循时间局部性原理：** LFU 关注的是**历史总访问次数**，而不是最近的访问情况。一个在程序启动初期被频繁访问的块，即使后来不再使用，其计数器也会非常高，导致它长期占据 Cache，而真正热点的数据可能无法进入。例如，视频聊天数据会使计数器持续增加，即使不再使用也难以被替换。
* **实际效果不佳：** 由于其“历史决定论”的特点，LFU 在许多实际场景中的命中率不如 LRU。
* **硬件实现成本较高：** 计数器