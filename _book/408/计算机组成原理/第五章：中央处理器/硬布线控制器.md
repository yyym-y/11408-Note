# 控制器设计

---

## 1. 硬布线控制器

### 1.1 内容回顾

* **指令周期的概念**: 一条指令的执行被划分为四个基本阶段：
    * **取指周期 (FE=1)**: 从内存中取出指令。
    * **间址周期 (IND=1)**: 如果需要，获取操作数的有效地址。
    * **执行周期 (EX=1)**: 执行指令规定的操作。
    * **中断周期 (INT=1)**: 处理可能发生的中断请求。
* **多级间址**: 采用间接寻址的指令可能需要多次间址周期。例如，二级间接寻址就需要两次间址周期才能最终获得操作数的有效地址。
* **触发器标识**: CPU 内部通过 **FE、IND、EX、INT** 这四个标志触发器来标识当前所处的机器周期。当某个触发器值为 1 时，表示 CPU 正处于该对应的周期。

#### 1.1.1 指令执行过程中的微操作与微命令

* **微操作并行性**: 在**专用数据通路结构**下，多个不冲突的微操作可以**并行执行**。例如，在一个节拍内，可以同时完成 `PC → MAR` (将 PC 内容送入 MAR) 和 `MemR` (向主存发送读信号) 这两个微操作，因为它们控制的是不同的硬件部件。
* **微操作复用**: 同一个微操作可能在不同指令的不同阶段被重复使用。例如，`M(MAR) → MDR` (将 MAR 指向的内存数据读入 MDR) 这个微操作在取指周期、间址周期和执行周期都可能用到。
* **定长机器周期**: 为了简化电路设计，硬布线控制器通常采用**定长机器周期**。这意味着每个机器周期都包含固定数量的节拍（例如，以访存操作所需的最大节拍数，如 3 个节拍为基准：T0, T1, T2）。即使某些操作实际耗时较短，也会占用完整的节拍，以保持时序的统一性。

#### 1.1.2 控制器设计的基础 (07:40)

控制单元 (CU) 生成微命令需要综合考虑以下四个判断维度：

1.  **指令操作码**: 确定当前正在执行的指令类型，这是微命令生成的首要依据。
2.  **机器周期触发器**: 判断当前 CPU 所处的机器周期（FE/IND/EX/INT），决定了当前阶段的大致操作类型。
3.  **节拍信号**: 确定当前机器周期内的具体时间点（T0/T1/T2...），精确控制微操作的发生时序。
4.  **机器状态条件**: 来自运算器 (如 PSW 中的溢出、零、符号标志，ACC 的值)、I/O 设备和主存的反馈信号，这些状态可能会影响指令的执行流程（如条件转移指令）。

* **微命令生成**: 结合上述四个维度信息，控制单元 CU 可以确定在当前节拍应发出的具体微命令。

### 1.2 控制单元 CU 

#### 1.2.1 硬布线控制器的介绍

* **实现方式**: 硬布线控制器是通过**纯硬件电路**（组合逻辑电路和时序逻辑电路）来实现控制功能的。它与**微程序控制器**形成对比，后者通过存储在控制存储器中的微程序来生成控制信号。
* **核心思想**: 将控制逻辑**固化在电路连接中**，通过门电路的组合直接生成微命令。

#### 1.2.2 操作码译码器的作用与原理

* **输入输出**: 接收指令寄存器 (IR) 中 `n` 位的操作码作为输入。它会输出 `2^n` 种可能的译码状态，每种状态对应一种不同的指令类型。
* **工作原理**: 当特定的操作码输入时，译码器会使对应指令的输出线变为高电平（有效），从而激活后续的控制逻辑。例如，操作码 `0000` 可能使 0 号输出线有效，表示这是一条特定的指令。

#### 1.2.3 判断当前机器周期的方法

* **触发器输入**: 将 **FE、IND、EX、INT** 这四个周期标志触发器的值输入到 CU。
* **周期判断**: CU 通过检测哪个触发器为 1 来确定当前 CPU 所处的机器周期。

#### 1.2.4 节拍发生器的原理与作用

* **工作方式**: 节拍发生器接收 CPU 的**时钟脉冲**，并循环输出一系列的**节拍信号**（如 T0, T1, T2...）。
* **定长周期**: 通常，每个机器周期包含固定数量的节拍（例如 3 个节拍），这有助于简化整个电路的设计。

#### 1.2.5 机器状态条件的输入与影响

* **状态来源**:
    * **运算器**: 例如 `PSW` (程序状态字寄存器) 中的溢出标志、正负标志、零标志，以及 `ACC` (累加器) 的值等。
    * **I/O 设备和主存**: 它们也会向 CU 提供反馈信号，例如 I/O 设备的中断请求信号，或主存的忙/就绪信号。
* **执行流控制**: 这些状态条件可能会改变微操作序列的执行流程，例如，条件转移指令会根据 `PSW` 中的标志位来决定是否跳转。

#### 1.2.6 控制单元 CU 的输出与微命令

* **输出形式**: CU 的每条输出线都对应一个具体的**微命令**（或控制信号）。例如，`C1` 这条输出线可能对应 `PCout` 和 `MARin` 这两个微命令。
* **电路连接**: 这些输出线直接连接到相应部件的控制端。例如，`C1` 将连接到 `PC` 的输出使能端和 `MAR` 的输入使能端。

#### 1.2.7 逻辑表达式与电路设计的关联

* **设计示例**: 某个微命令的逻辑表达式可能为 `M(MAR)→MDR = FE · T1 + EX · T1 · (ADD + LDA)`。
* **数学化描述**: 逻辑表达式精确地描述了电路应满足的条件关系。例如，`FE · T0` 对应一个与门，当 `FE` 和 `T0` 都为 1 时，与门输出 1，触发相应的微命令。

#### 1.2.8 微命令逻辑表达式的确定方法

* **简单情况**: 对于仅在某个特定条件下使用的微操作（例如，只在取指周期 T0 节拍才发生的 `PC → MAR`），其逻辑表达式相对简单。
* **复杂情况**: 对于在多处使用的微操作（例如 `M(MAR) → MDR`，它在取指周期、间址周期和执行周期都可能用到），需要**综合所有使用场景**来确定其逻辑表达式。
* **设计挑战**: 高频复用的微操作的逻辑表达式确定是硬布线控制器设计的难点，因为需要考虑所有可能的触发条件并进行化简。

### 1.3 微操作命令的逻辑表达式

#### 1.3.1 逻辑表达式解析

* **表达式结构**: 承接之前的例子，`M(MAR)→MDR = FE · T1 + EX · T1 · (ADD + LDA)`。
* **电路实现原理**: 这个表达式通过**组合逻辑电路**实现。它表示当 CPU 处于取指阶段 (FE=1) 且是 T1 节拍时，会触发 `M(MAR)→MDR` 微操作；或者当处于执行阶段 (EX=1) 的 T1 节拍，并且当前指令是 `ADD` 或 `LDA` 时，也会触发 `M(MAR)→MDR` 微操作。
* **信号来源**:
    * **周期信号** (FE, IND, EX 等) 来自 CU 内部的触发器。
    * **指令信号** (ADD, LDA 等) 来自操作码译码器。
    * **节拍信号** (T0-T2) 由节拍发生器循环产生。

#### 1.3.2 硬布线控制器设计步骤

硬布线控制器的设计是一个系统性的过程：

1.  **微操作序列分析**: 详细分析所有指令在**取指、间址、执行、中断**四个阶段的微操作序列。其中，**执行阶段的微操作差异最大**，需要针对每条指令单独分析。
2.  **控制方式选择**: 确定采用**定长或不定长机器周期**。通常为了简化设计，会假设采用**同步控制方式**（定长周期，例如每周期 3 个节拍 T0-T2）。
3.  **时序安排**: 将每个微操作合理地分配到各个节拍中，确定它们的执行顺序和并行可能性。
4.  **电路实现**: 为每个微命令设计逻辑表达式，并基于这些表达式实现对应的组合逻辑电路。

#### 1.3.3 典型微操作示例

* **取指周期 T0 节拍**: `PC → MAR`。对应的逻辑表达式可能为 `PC→MAR = FE · T0`。
* **取指周期 T1 节拍**: `M(MAR) → MDR`。对应的逻辑表达式如前所述，会是一个更复杂的综合表达式。

#### 1.3.4 控制信号生成原理

* **核心组件**:
    * **操作码译码器**: 将指令操作码转换为对应的控制线信号（例如，`ADD` 指令激活 `ADD` 信号线）。
    * **节拍发生器**: 每个时钟周期发出一个节拍信号（T0-T2 循环），提供时间基准。
    * **组合逻辑电路**: 根据当前周期标志、节拍信号、指令操作码和机器状态条件，通过门电路的组合**即时生成**微命令。
* **实现示例**: 要实现微操作 `PC → MAR`，其控制信号线会将 `FE · T0` 对应的逻辑电路输出连接到 `PCout` 和 `MARin` 控制端。
* **设计特点**:
    * 逻辑表达式本质上是操作码电路的**数学化描述**。
    * FE、IND、EX、INT 四个周期标志触发器集成在 CU 内部。
    * CU 需要接收来自 PSW、ACC 等执行单元的**反馈信息**，以处理条件分支等。

### 1.4 硬布线控制器的设计 (22:52)

#### 1.4.2 微操作序列总结与设计步骤 (31:07)

* **设计步骤**:
    1.  **分析各阶段微操作序列**：包括取指、间址、执行、中断。
    2.  **选择 CPU 控制方式**：确定是定长还是不定长机器周期。
    3.  **安排微操作时序**：将微操作合理分配到各个节拍（例如，在 3 个节拍内完成）。
    4.  **电路设计**：包括绘制操作时间表、写出微命令逻辑表达式、绘制逻辑图。
* **关键因素**:
    * **指令操作码**
    * **当前机器周期**
    * **节拍信号**
    * **机器状态条件**

#### 1.4.3 安排微操作时序的原则 (32:25)

1.  **原则一：顺序不可更改**：微操作之间的**先后依赖关系必须严格遵守**。例如，必须先将地址送入 `MAR` 才能进行访存。
2.  **原则二：被控对象不同可并行**：控制**不同硬件对象**的微操作可以安排在**同一节拍**内并行执行。例如，`PC → MAR` 和 `MemR`。
3.  **原则三：短时操作可合并**：耗时较短的 CPU 内部寄存器间的数据传输操作，可以安排在同一节拍内，甚至可以允许有先后顺序（在同一个节拍内，但通过门延迟控制）。

##### 1.4.3.1 取指周期时序安排 (33:37)

* **T0 节拍**: `PC → MAR` 和 `MemR` (被控对象不同，可并行)。
* **T1 节拍**: `M(MAR) → MDR` 和 `PC + 1 → PC` (无依赖关系，可并行)。
* **T2 节拍**: `MDR → IR` 和 `IR_opcode → ID` (耗时短，可合并)。
* **关键点**:
    * **访存操作需要完整的节拍**（例如 `MemR` 和 `M(MAR) → MDR` 之间通常需要等待内存响应）。
    * CPU 内部寄存器间的数据传输通常可以快速完成。

##### 1.4.3.2 间址周期时序安排 (37:27)

* **T0 节拍**: `Ad(IR) → MAR` 和 `MemR`。
* **T1 节拍**: `M(MAR) → MDR`。
* **T2 节拍**: `MDR → Ad(IR)`。
* **特点**: 必须保证访存操作单独占用节拍。最后一步完成有效地址的更新。

##### 1.4.3.3 执行周期时序安排 (37:52)

* **非访存指令**: 通常安排在**最后一个节拍 (T2)** 完成，例如 `CLA` (清零)、`COM` (取反)、`SHR` (右移) 等指令。
* **访存指令**: 需要多个节拍来完成访存操作，例如 `LDA` (加载)、`ADD` (加法) 等指令。
* **转移指令**: 条件转移指令需要考虑状态条件（如 `SF` 标志），通常安排在最后一个节拍完成 `PC` 的更新。

#### 1.4.4 组合逻辑设计 (40:20)

硬布线控制器的电路设计通常分为三步：

1.  **列出操作时间表 (40:27)**:
    * **设计步骤**: 需要列出取指、间址、执行、中断四个机器周期内，以及 T0、T1、T2 节拍中可能用到的所有微操作。
    * **参考依据**: 王道书表 5.1 通常提供了完整的微操作时序参考表。
2.  **写出微操作命令的最简表达式 (40:58)**:
    * **目标**: 为每个微操作命令获得其对应的逻辑表达式。
    * **方法**: 通过分析操作时间表，确定各微操作在不同周期、节拍和指令条件下的触发条件，并写出逻辑表达式。
3.  **画出逻辑图 (41:08)**:
    * **实现方式**: 根据化简后的逻辑表达式设计对应的组合逻辑电路。
    * **电路本质**: 逻辑表达式是电路设计的数学化描述。

##### 1.4.4.1 取指周期操作时间表 (41:17)

* **公共操作**:
    * `T0` 节拍：`PC → MAR` 和 `MemR`。
    * `T1` 节拍：`M(MAR) → MDR` 和 `PC + 1 → PC`。
    * `T2` 节拍：`MDR → IR` 和 `IR_opcode → ID`。
* **状态条件**:
    * 在 `T2` 节拍，如果指令是**非间接寻址**时：将 `EX` 标志位设为 1（进入执行周期）。
    * 在 `T2` 节拍，如果指令是**间接寻址**时：将 `IND` 标志位设为 1（进入间址周期）。
* **指令分类**:
    * 前 5 条非访存指令：通常直接进入执行阶段。
    * 后 5 条指令：可能进入间址阶段（若采用间接寻址）。

##### 1.4.4.2 间址周期操作时间表 (44:16)

* **必要条件**: `IND=1` 表示处于间址周期。
* **常规操作**:
    * `T0` 节拍：`Ad(IR) → MAR` 和 `MemR`。
    * `T1` 节拍：`M(MAR) → MDR`。
    * `T2` 节拍：`MDR → Ad(IR)`。
* **多级间址处理**:
    * 如果**标志位 `IND_flag = 0`**（表示已完成最后一级间址）：进入执行周期（`EX=1`）。
    * 如果**标志位 `IND_flag = 1`**（表示还需要进行下一级间址）：继续进行下一级间址（`IND=1` 保持）。

##### 1.4.4.3 执行周期操作时间表 (45:56)

* **操作整合**: 将各指令在 T0、T1、T2 节拍中可能用到的微操作统一列出。
* **典型操作**:
    * `CLA` 指令：`0 → ACC`。
    * `LDA` 指令：`Ad(IR) → MAR`、`MemR`、`M(MAR) → MDR`、`MDR → ACC`。
    * `ADD` 指令：`Ad(IR) → MAR`、`MemR`、`M(MAR) → MDR`、`ACC + MDR → ACC`。
    * `JMP` 指令：`Ad(IR) → PC`。
    * `BAN` 指令：`SF · Ad(IR) → PC`。

##### 1.4.4.4 微操作命令逻辑表达式 (48:31)

* **表达式推导**: 以 `M(MAR) → MDR` 为例：
    * **取指周期**: 在 `FE=1` 且 `T1=1` 时发生。
    * **间址周期**: 在 `IND=1` 且 `T1=1` 时发生。
    * **执行周期**: 在 `EX=1` 且 `T1=1`，并且指令是 `ADD` 或 `LDA` 时发生。
    * **综合表达式**: `M(MAR)→MDR = FE · T1 + IND · T1 + EX · T1 · (ADD + LDA)`。

##### 1.4.4.5 逻辑表达式化简与电路图 (51:52)

* **化简方法**: 提取公因子，例如 `M(MAR)→MDR = T1 · (FE + IND + EX · (ADD + LDA))`。
* **电路实现**: 将化简后的表达式转换为组合逻辑电路。电路输入包括：**周期标记** (FE, IND, EX)、**节拍信号** (T0, T1, T2)、**指令操作码** (ADD, LDA 等)。输出为对应的**微操作控制信号**。
* **硬件集成**: 将设计好的电路集成到 CU 内部，连接到相应部件的控制信号线。

### 1.5 硬布线控制器的特点 (53:34)

* **设计流程**: 遵循四个关键步骤：分析微操作序列 → 选择控制方式 → 安排时序 → 电路设计（含操作时间表、逻辑表达式、逻辑图三环节）。

#### 1.5.1 硬布线控制器的设计步骤 (53:44)

* **阶段分析**:
    * **指令分解**: 需罗列所有指令在取指、间址、执行等各阶段的微操作序列。
    * **控制方式选择**: 需确定机器周期是否定长、每个周期包含的节拍数。
    * **时序安排**: 将微操作分配到具体节拍（如 T0/T1/T2）。
    * **电路实现**:
        * **操作时间表**: 建立指令周期-节拍-微操作的映射关系表。
        * **逻辑优化**: 通过卡诺图等方法将微操作命令表达式化简（如提取公因子等组合）。
        * **硬件实现**: 基于最简表达式绘制组合逻辑电路图。

#### 1.5.2 指令数量对设计和实现的影响 (55:05)

* **复杂度关系**: 硬布线控制器的设计难度与指令数量呈**指数级增长**。例如，仅分析 10 条指令就已经需要非常复杂的设计。
* **适用场景**: 通常用于 **RISC (精简指令集计算机)** 架构，因为其指令条数较少（通常只有几十条），电路复杂度尚可接受。
* **对比说明**: **CISC (复杂指令集计算机)** 架构（如 x86 包含数百条指令）若采用硬布线控制器，其电路复杂度将难以承受，因此通常采用微程序控制器。

#### 1.5.3 扩充指令的困难性 (56:01)

* **修改代价**: 新增一条指令通常需要**重新设计和修改**涉及的所有电路模块。例如，如果新指令需要用到某个微操作，那么该微操作的逻辑表达式就需要重新计算，并可能导致原有电路的调整。
* **耦合问题**: 纯硬件实现导致指令集与电路之间**高度耦合**。若新指令的逻辑与现有电路不兼容，原有电路可能完全作废，需要进行大规模重构。

#### 1.5.4 执行速度快 (56:47)

* **性能优势**: 硬布线控制器由于微操作信号通过门电路**直接生成**，没有存储-译码的延迟，因此执行速度非常快。
* **典型应用**: 现代 CPU 中对时间延迟要求极高的**关键路径**（如超标量流水线中的指令译码和调度）常采用硬布线控制。
* **设计权衡**: 以**硬件复杂度换取执行速度**，适合对延迟敏感的场景。

---

## 二、知识小结

| 知识点              | 核心内容                                                     | 考试重点/易混淆点                                           | 难度系数 |
| :------------------ | :----------------------------------------------------------- | :---------------------------------------------------------- | :------- |
| 控制器类型          | **硬布线控制器**与**微程序控制器**的区别与实现方式。       | **硬布线纯硬件实现 vs 微程序软硬结合**。                    | ⭐⭐⭐⭐   |
| 机器周期            | 取指/间址/执行/中断四个标准周期及节拍分配。                | **多级间址需重复间址周期**。                                | ⭐⭐⭐     |
| 微操作并行          | 被控对象不同的操作可并行（如 `PC → MAR` 与存储器读信号）。 | **定长机器周期的节拍冗余设计**。                            | ⭐⭐⭐⭐   |
| 控制信号生成        | **操作码 + 机器周期 + 节拍 + 状态标志** 四维判断逻辑。     | **FE/IND/EX/INT 触发器状态组合**。                          | ⭐⭐⭐⭐⭐ |
| 硬布线设计步骤      | 1. 指令微操作分析 → 2. 控制方式选择 → 3. 时序安排 → 4. 电路实现。 | **操作时间表与逻辑表达式转换**。                            | ⭐⭐⭐⭐   |
| RISC 适用性         | 指令扩展需重构电路 vs 微程序控制器易扩展。                 | **执行速度硬布线 > 微程序**。                               | ⭐⭐⭐     |
| 关键微操作          | `M(MAR) → MDR` 在取指(T1)/间址(T2)/执行周期(ADD/LDA) 复用。 | **同一微操作多场景触发条件**。                              | ⭐⭐⭐⭐   |